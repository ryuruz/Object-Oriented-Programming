# Inheritance

## 상속의 개념
* 객체지향의 상속
	* 부모 클래스에 만들어진 필드, 메소드를 자식클래스가 물려받음
	* 동일한 특성을 재정의할 필요가 없어 간결하게 자식 클래스 작성 가능

* 상속의 장점
	* 클래스의 간결화
	* 관리 용이 -> 클래스들의 계층적 분류
	* 소프트웨어 생산성 향상

## 클래스 상속과 객체
```java
public class Person{~}
public class Student extends Person{~}
```
+ 부모 클래스(super class)
+ 자식 클래스(sub class)
+ 상속을 위해서는 `extends` 키워드 사용 

## 자바 상속의 특징
+ 다중 상속 지원 x
+ 쭉 아래로 상속 가능 (상속 횟수 무제한)
+ 상속의 최상위 조상 클래스 java.lang.Object 클래스
	+ 모든 클래스는 자동으로 이를 상속받음
	+ 컴파일러에 의해 자동으로 이루어짐
	
## 상속과 접근 지정자
+ 슈퍼 클래스의 __private__ 멤버
	+ 다른 모든 클래스에서의 접근 불허
	+ 클래스 내의 멤버들에게만 접근 허용
+ 슈퍼 클래스의 __protected__ 멤버
	+ 같은 패키지 내의 모든 클래스에서의 접근 허용
	+ 다른 패키지에 있어도, 서브 클래스에서는는 접근 가능
+ 슈퍼 클래스의 default 멤버
	+ 패키지 내의 모든 클래스에서의 접근 허용
+ 슈퍼 클래스의 public 멤버
	+ 다른 모든 클래스에서의 접근 허용

## 상속에 따른 클래스의 생성자 호출 및 실행
+ 서브 클래스의 객체가 생성되는 경우
	+ 서브 클래스의 생성자와 슈퍼 클래스의 생성자가 모두 실행됨
	+ 슈퍼 클래스의 생성자가 먼저 실행된 후 서브 클래스의 생성자 실행됨
+ new에 의해 서브클래스의 객체가 생성될 때
	+ 호출 순서 : 서브 클래스의 생성자, 실핸 전 슈퍼 클래스 생성자 호출 -> 슈퍼 클래스의 생성자
	+ 실행 순서 : 슈퍼 클래스 -> 서브 클래스

1. 기본 생성자가 자동 선택되는 경우
+ 명시적 지시가 없는 경우, 서브 클래스의 생성자가 기본 생성자이든, 매개변수를 가진 것이든, 슈퍼 클래스의 기본 생성자가 선택된다.
+ 자바 컴파일러에 의해 강제로 이루어짐

2. 슈퍼 클래스에 기본 생성자가 없어 오류난 경우

```java
class A{
	public A(int x){
		System.out.println("생성자 A");
	}
}
class B extends A{
	public B(){ 
		System.out.println("생성자 B");
	}
}

public class ConstructorEx2{
	public static void main(string[] args){
	B b;
	b = new B(); 
	}
}
```

+ 클래스 A에 기본 생성자 없음
+ 클래스 B의 기본 생성자와 짝을 이룰 기본 생성자가 없어 오류 발생

3. 서브 클래스에 매개변수를 가진 생성자 

```java
class A{
	public A(){
		System.out.print("생성자 A ");
	}
	public A(int x){
		System.out.print("매개변수 생성자 A ");
	}
}
class B extends A{
	public B(){ 
		System.out.print("생성자 B ");
	}
	public B(int x){
		System.out.print("매개변수 생성자 B ");
	}
}

public class ConstructorEx2{
	public static void main(string[] args){
	B b;
	b = new B(5); // 
	}
}
```

+ 실행결과 : 생성자 A 매개변수 생성자B
+ 이 경우에도 개발자의 특별한 지시가 없으면 슈퍼 클래스의 기본 생성자가 호출됨
+ 컴파일러에 의해 `super()` 자동으로 첫 줄에 추가되기 때문

4. super() 이용하여 명시적으로 슈퍼 클래스의 생성자 선택 

```java
class A{
	public A(){
		System.out.print("생성자 A ");
	}
	public A(int x){
		System.out.print("매개변수 생성자 A ");
	}
}
class B extends A{
	public B(){ 
		System.out.print("생성자 B ");
	}
	public B(int x){
		super(x); // 반드시 첫 줄
		System.out.print("매개변수 생성자 B ");
	}
}

public class ConstructorEx2{
	public static void main(string[] args){
	B b;
	b = new B(5); // 
	}
}
```
+ 실행 결과 : 매개변수 생성자 A 매개변수 생성자 B

___

## 업캐스팅(Upcasting) 
+ 서브 클래스 객체를 슈퍼 클래스 타입으로 변환
+ 업캐스팅이 되면, 객체 내에 있는 슈퍼 클래스의 멤버에만 접근 가능 
```java
class Person {~}
class Student extends Person{~}

Student s = new Student();
Person p = sl // 업캐스팅으로, 자동타입변환됨
```

## 다운캐스팅(Downcasting)
+ 슈퍼 클래스 변수에 들어있는 레퍼런스를 서브 클래스 타입으로 변환
+ 명시적 타입 변환이 필요함
```java
class Person {~}
class Student extends Person{~}

Person p = new Student(); // 업캐스팅
Student s = (Student) p // 다운 캐스팅, 타입 변환 표시 
```
### instanceof 연산자
+ 위 코드 실행 시 실제로 서브 클래스 객체가 아니면 오류 발생함
+ 레퍼런스가 가리키는 객체의 타입 식별을 위해 사용함
+ `객체레퍼런스 instanceof 클래스 타입` true/false의 boolean값 받음
+ 객체에 대한 레퍼런스만 사용하기 때문에 `if(3 instacneof int)`처럼 사용불가

## 메소드 오버라이딩
+ 슈퍼 클래스의 메소드를 서브 클래스에서 재정의
+ 메소드의 이름, 매개변수 타입 및 개수, 리턴 타입 등을 모두 동일하게 작성 <-> 메소드 오버로딩
+ 서브 클래스에 오버라이딩된 메소드가 무조건 실행되는 동적 바인딩이 발생함
+ 슈퍼 클래스에 선언된 메소드를, 각 서브 클래스들이 자신만의 내용으로 새로 구현하는 기능
+ __실행 시간 다형성__ 실현

### 동적 바인딩
+ 실행할 메소드를 실행 시에 결정
+ 오버라이딩 메소드가 항상 호출됨

### super
+ super는 슈퍼 클래스의 멤버를 접근할 때 사용되는 레퍼런스
+ 서브 클래스에서만 사용
+ super의 접근은 정적 바인딩

비교 요소 | 메소드 오버로딩 | 메소드 오버라이딩
---|---|---
선언 | 같은 클래스나 상속 관계에서 동일한 이름의 메소드 중복 작성 | 서브 클래스에서 슈퍼 클래스에 있는 메소드와 동일한 이름의 메소드 재작상
관계 | 동일한 클래스 내 혹은 상속 관계 | 상속 관계
목적 | 이름이 같은 여러 개의 메소드를 중복 작성하여 사용의 편리성 향상, 다형성 실현 | 슈퍼 클래스에 구현된 메소드를 무시하고 서브 클래스에서 새로운 기능의 메소드를 재정의하고자 함. 다형성 실현
조건 | 메소드 이름은 반드시 동일하고, 매개변수 타입이나 갯가 달라야 성립 | 메소드의 이름, 매개변수 타입과 개수, 리턴 타입이 모두 동일해야 성립
바인딩 | 정적 바인딩. 호출될 메소드는 컴파일 시에 결정 | 동적 바인딩. 실행 시간에 오버라이딘된 메소드 찾아 호출 

___
## 추상 메소드 (Abstract Method)
+ 선언되어 있으나 구현되어 있지 않은 메소드
+ `abstract`로 선언
+ 서브 클래스에서 오버라이딩하여 구현해야 함

## 추상 클래스 (Abstract Class)
+ 추상클래스는 객체 생성이 불가함
+ 추상 메소드를 하나라도 가진 클래스는 클래스 앞에 abstract 선언 필수
+ 추상 메소드를 가지고 있지 않은 클래스도 abstract로 선언 가능

### 추상 클래스의 상속
+부모 클래스에 추상 메소드가 있는 경우 
	+ 자식 클래스에서 추상 메소드를 구현하지 않은 경우 : 자식 클래스도 추상클래스로, abstract 선언 필수
	+ 자식 클래스에서 추상 메소드를 구현한 경우 : 자식 클래스는 추상 클래스가 아니어도 됨
	
### 추상클래스의 용도
+ 계층적 상속 관계를 갖는 클래스 구조를 만들 때
+ 설계와 구현 분리
	* 개념만 정의 - 서브 클래스마다 다른 구현이 필요한 메소드는 추상 메소드로 선언
	* 구체적 행위 구현 - 각 서브 클래스마다 목적에 맞게 다르게 구현


___
인터페이스
