# Inheritance

## 상속의 개념
* 객체지향의 상속
	* 부모 클래스에 만들어진 필드, 메소드를 자식클래스가 물려받음
	* 동일한 특성을 재정의할 필요가 없어 간결하게 자식 클래스 작성 가능

* 상속의 장점
	* 클래스의 간결화
	* 관리 용이 -> 클래스들의 계층적 분류
	* 소프트웨어 생산성 향상

## 클래스 상속과 객체
```java
public class Person{~}
public class Student extends Person{~}
```
+ 부모 클래스(super class)
+ 자식 클래스(sub class)
+ 상속을 위해서는 `extends` 키워드 사용 

## 자바 상속의 특징
+ 다중 상속 지원 x
+ 쭉 아래로 상속 가능 (상속 횟수 무제한)
+ 상속의 최상위 조상 클래스 java.lang.Object 클래스
	+ 모든 클래스는 자동으로 이를 상속받음
	+ 컴파일러에 의해 자동으로 이루어짐
	
## 상속과 접근 지정자
+ 슈퍼 클래스의 __private__ 멤버
	+ 다른 모든 클래스에서의 접근 불허
	+ 클래스 내의 멤버들에게만 접근 허용
+ 슈퍼 클래스의 __protected__ 멤버
	+ 같은 패키지 내의 모든 클래스에서의 접근 허용
	+ 다른 패키지에 있어도, 서브 클래스에서는는 접근 가능
+ 슈퍼 클래스의 default 멤버
	+ 패키지 내의 모든 클래스에서의 접근 허용
+ 슈퍼 클래스의 public 멤버
	+ 다른 모든 클래스에서의 접근 허용

## 상속에 따른 클래스의 생성자 호출 및 실행
+ 서브 클래스의 객체가 생성되는 경우
	+ 서브 클래스의 생성자와 슈퍼 클래스의 생성자가 모두 실행됨
	+ 슈퍼 클래스의 생성자가 먼저 실행된 후 서브 클래스의 생성자 실행됨
+ new에 의해 서브클래스의 객체가 생성될 때
	+ 호출 순서 : 서브 클래스의 생성자, 실핸 전 슈퍼 클래스 생성자 호출 -> 슈퍼 클래스의 생성자
	+ 실행 순서 : 슈퍼 클래스 -> 서브 클래스

1. 기본 생성자가 자동 선택되는 경우
+ 명시적 지시가 없는 경우, 서브 클래스의 생성자가 기본 생성자이든, 매개변수를 가진 것이든, 슈퍼 클래스의 기본 생성자가 선택된다.
+ 자바 컴파일러에 의해 강제로 이루어짐

2. 슈퍼 클래스에 기본 생성자가 없어 오류난 경우

```java
class A{
	public A(int x){
		System.out.println("생성자 A");
	}
}
class B extends A{
	public B(){ 
		System.out.println("생성자 B");
	}
}

public class ConstructorEx2{
	public static void main(string[] args){
	B b;
	b = new B(); 
	}
}
```

+ 클래스 A에 기본 생성자 없음
+ 클래스 B의 기본 생성자와 짝을 이룰 기본 생성자가 없어 오류 발생

3. 서브 클래스에 매개변수를 가진 생성자 

```java
class A{
	public A(){
		System.out.print("생성자 A ");
	}
	public A(int x){
		System.out.print("매개변수 생성자 A ");
	}
}
class B extends A{
	public B(){ 
		System.out.print("생성자 B ");
	}
	public B(int x){
		System.out.print("매개변수 생성자 B ");
	}
}

public class ConstructorEx2{
	public static void main(string[] args){
	B b;
	b = new B(5); // 
	}
}
```

+ 실행결과 : 생성자 A 매개변수 생성자B
+ 이 경우에도 개발자의 특별한 지시가 없으면 슈퍼 클래스의 기본 생성자가 호출됨
+ 컴파일러에 의해 `super()` 자동으로 첫 줄에 추가되기 때문

4. super() 이용하여 명시적으로 슈퍼 클래스의 생성자 선택 

```java
class A{
	public A(){
		System.out.print("생성자 A ");
	}
	public A(int x){
		System.out.print("매개변수 생성자 A ");
	}
}
class B extends A{
	public B(){ 
		System.out.print("생성자 B ");
	}
	public B(int x){
		super(x); // 반드시 첫 줄
		System.out.print("매개변수 생성자 B ");
	}
}

public class ConstructorEx2{
	public static void main(string[] args){
	B b;
	b = new B(5); // 
	}
}
```
+ 실행 결과 : 매개변수 생성자 A 매개변수 생성자 B

___

## 업캐스팅(Upcasting) 
+ 서브 클래스 객체를 슈퍼 클래스 타입으로 변환
+ 업캐스팅이 되면, 객체 내에 있는 슈퍼 클래스의 멤버에만 접근 가능 
```java
class Person {~}
class Student extends Person{~}

Student s = new Student();
Person p = sl // 업캐스팅으로, 자동타입변환됨
```

## 다운캐스팅(Downcasting)
+ 슈퍼 클래스 변수에 들어있는 레퍼런스를 서브 클래스 타입으로 변환
+ 명시적 타입 변환이 필요함
```java
class Person {~}
class Student extends Person{~}

Person p = new Student(); // 업캐스팅
Student s = (Student) p // 다운 캐스팅, 타입 변환 표시 
```
### instanceof 연산자
+ 위 코드 실행 시 실제로 서브 클래스 객체가 아니면 오류 발생함
+ 레퍼런스가 가리키는 객체의 타입 식별을 위해 사용함
+ `객체레퍼런스 instanceof 클래스 타입` true/false의 boolean값 받음
+ 객체에 대한 레퍼런스만 사용하기 때문에 `if(3 instacneof int)`처럼 사용불가

## 메소드 오버라이딩
+ 슈퍼 클래스의 메소드를 서브 클래스에서 재정의
+ 메소드의 이름, 매개변수 타입 및 개수, 리턴 타입 등을 모두 동일하게 작성 <-> 메소드 오버로딩
+ 서브 클래스에 오버라이딩된 메소드가 무조건 실행되는 동적 바인딩이 발생함
+ 슈퍼 클래스에 선언된 메소드를, 각 서브 클래스들이 자신만의 내용으로 새로 구현하는 기능
+ __실행 시간 다형성__ 실현

### 동적 바인딩
+ 실행할 메소드를 실행 시에 결정
+ 오버라이딩 메소드가 항상 호출됨

### super
+ super는 슈퍼 클래스의 멤버를 접근할 때 사용되는 레퍼런스
+ 서브 클래스에서만 사용
+ super의 접근은 정적 바인딩

비교 요소 | 메소드 오버로딩 | 메소드 오버라이딩
---|---|---
선언 | 같은 클래스나 상속 관계에서 동일한 이름의 메소드 중복 작성 | 서브 클래스에서 슈퍼 클래스에 있는 메소드와 동일한 이름의 메소드 재작상
관계 | 동일한 클래스 내 혹은 상속 관계 | 상속 관계
목적 | 이름이 같은 여러 개의 메소드를 중복 작성하여 사용의 편리성 향상, 다형성 실현 | 슈퍼 클래스에 구현된 메소드를 무시하고 서브 클래스에서 새로운 기능의 메소드를 재정의하고자 함. 다형성 실현
조건 | 메소드 이름은 반드시 동일하고, 매개변수 타입이나 갯가 달라야 성립 | 메소드의 이름, 매개변수 타입과 개수, 리턴 타입이 모두 동일해야 성립
바인딩 | 정적 바인딩. 호출될 메소드는 컴파일 시에 결정 | 동적 바인딩. 실행 시간에 오버라이딘된 메소드 찾아 호출 

___
## 추상 메소드 (Abstract Method)
+ 선언되어 있으나 구현되어 있지 않은 메소드
+ `abstract`로 선언
+ 서브 클래스에서 오버라이딩하여 구현해야 함

## 추상 클래스 (Abstract Class)
+ 추상클래스는 객체 생성이 불가함
+ 추상 메소드를 하나라도 가진 클래스는 클래스 앞에 abstract 선언 필수
+ 추상 메소드를 가지고 있지 않은 클래스도 abstract로 선언 가능

### 추상 클래스의 상속
+부모 클래스에 추상 메소드가 있는 경우 
	+ 자식 클래스에서 추상 메소드를 구현하지 않은 경우 : 자식 클래스도 추상클래스로, abstract 선언 필수
	+ 자식 클래스에서 추상 메소드를 구현한 경우 : 자식 클래스는 추상 클래스가 아니어도 됨
	
### 추상클래스의 용도
+ 계층적 상속 관계를 갖는 클래스 구조를 만들 때
+ 설계와 구현 분리
	* 개념만 정의 - 서브 클래스마다 다른 구현이 필요한 메소드는 추상 메소드로 선언
	* 구체적 행위 구현 - 각 서브 클래스마다 목적에 맞게 다르게 구현
___

## Interface
### 자바의 인터페이스
+ 클래스가 구현해야 할 메소드들이 선언되는 추상형
+ 인터페이스 선언
	+ `interface` 키워드로 선언
	+ 필드(멤버 변수) 선언 불가
	+ 상수 선언 가능
	+ 추상 메소드 선언 가능
```java
public interface AudioClip{
	final int TIMEOUT = 100;
	public abstract void play();
	public abstract void stio();
	public abstract void loop();
}
```
### 인터페이스 구성 요소들의 특징
#### public 구성 요소
+ 상수 : `public static final` 생략 가능
+ 추상 메소드 : public abstract 생략 가능, 인터페이스를 구현하는 클래스에서 오버라이드 해야 함
+ defualt 메소드 : public 생략 가능, 인터페이스를 구현하는 클래스에서 오버라이드 하지 않아도 됨

#### 나머지 구성요소
+ private 메소드 : 인터페이스 내에 메소드 코드가 작성되어야 하며, 인터페이스 내부에서만 호출 가능
+ static 메소드 : public 또는 private 모두 가능, 생략하면 public으로 간주, 인터페이스 내의 다른 메소드에 의해 호출 가능(인터페이스이름.메소드이름())


### 인터페이스의 특징
+ 인터페이스의 객체 생성 불가
`new PhoneInterface(); // 오류`
+ 레퍼런스 변수 선언 가능
`PhoneInterface galaxy; // 인터페이스에 대한 레퍼런스 변수 galaxy'
+ 다른 인터페이스를 상속할 수 있으며, 다중 상속이 가능함
+ 인터페이스를 상속받는 클래스는 인터페이스의 모든 추상 메소드를 반드시 구현해야 함

### 인터페이스 구현
+ `implement` 키워드를 사용하여, 인터페이스의 모든 추상 메소드를 구현한 클래스 작성
+ 한 클래스는 여러 개의 인터페이스를 동시에 구현할 수 있음

### 인터페이스 상속
+ `extends` 키워드 이용
```java
inteface Mobile extends Phone{ // extends 키워드 이용
	// 새로운 추상 메소드 추가
	void sendSMS();
	void reveiceSMS();
}
```
+ 다중 인터페이스 상속
```java
inteface Mobile extends Phone, MP3{ 
	~
}
```

### 인터페이스의 목적
+ 클래스들이 그 기능을 서로 다르게 구현할 수 있도록 하는 클래스의 규격 선언
+ 클래스 다형성 실현 가능


### 추상 클래스와 인터페이스
+ 유사점
	+ 객체 생성이 불가하며, 상속을 위한 슈퍼 클래스로만 사용한다
	+ 클래스의 다형성 실현 가능

비교 | 목적 | 구성
:---:|:---:|:---:
추상 </br>클래스 | 서브 클래스에서 필요로 하는 대부분의 기능을 구현하여 두고, </br> 개별 구현이 필요한 것만을 추상 메소드로 선언하여 </br> 상속 후에 서브클래스에서 구현하도록 함| 추상 메소드, 일반 메소드 모두 포함 </br>  상수, 변수 필드 모두 포함
인터 </br>페이스 | 객체의 기능을 모두 공개한 표준화 문서로 </br> 클래스의 목적에 따라 추상 메소드를 만들도록 함| 변수 필드는 포함하지 않음 </br> 상수, 추상 메소드, 일반 메소드, default, static 메소드 모두 포함 </br> protected 접근 지정 선언 불가 </br> 다중 상속 지원

