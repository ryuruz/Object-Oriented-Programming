# Object Oriented Programming

## 객체지향의 특성
1. 캡슐화
+ 다른 객체들과 상호작용할 때, 객체들의 속성(주 코드)을 알 필요 없이 이용할 줄만 알면 됨

2. 상속
+ 상위 개체의 속성이 하위 개체에 물려짐
+ 부모 클래스(superclass)와 자식 클래스(subclass)
+ 자바에서는 다중 상속 불가

3. 다형성 (Polymorphism)
+ 같은 이름의 메소드가 클래스나 객체에 따라 다르게 동작하도록 구현
+ 메소드 오버로딩 : 같은 이름이지만 다르게 작동하는 여러 메소드
+ 메소드 오버라이딩 : 슈퍼클래스의 메소드를 서브 클래스마다 다르게 구형

## 클래스와 객체
### 클래스(class)
+ 객체 모양을 선언한 틀
+ 메소드(멤버 함수)와 필드(멤버 변수)로 구성

#### 클래스의 구성
```java
public class Circle{
	public int rad;
	public String name;
	
	public Circle(){
	}
	public double getArea(){
		return 3.14*rad*rad;
	}
}
```

+ 클래스 선언 : `class Circle`
	+ 중괄호 안에 필드와 메소드를 작성함

+ 필드와 메소드
	+ 필드 : 객체 내에 값을 저장하는 멤버 변수 - rad, name의 두 필드 존재
	+ 메소드 : 함수로, 객체의 행동 구현 - gerArea()

+ 접근 지정자(access specifier)
	+ public을 통해 다른 클래스에서 활용, 접근 가능하게 선언
	+ 생략하는 경우 default

+ 생성자(constructor)
	+ 클래스의 이름과 동일한 메소드를 특별히 생성자로 부름
	+ 객체를 초기화할 때 필요한 코드 작성
	+ __리턴 타입 없음__
	+ 여러 개 작성 가능함 : __오버로딩__
		+ 이 경우, 매개변수의 개수, 타입, 타입의 순서가 서로 달라야 함
	+ 생략되는 경우 컴파일러에 의해 자동으로 생성 : 기본 생성자(default constructor)
		+ 매개 변수, 아무 작업 없음. 단순 리턴만
		+ 하나라도 생성자가 있는 경우, 기본 생성자는 삽입되지 않음
		
+ this 레퍼런스
	+ 현재 객체 자신에 대한 레퍼런스, 현재 실행되는 메소드가 속한 객체에 대한 레퍼런스
	+ 동일한 이름을 가진 경우 유용
	
```java
public class Circle{
	int rad;
	public CIrcle(int r){ this.rad = r; } // this를 통해 이 객체의 멤버변수인 rad에 접근
	public int getRad {return rad;}
}
```

+ this()
	+ 클래스 내에서 생성자가 다른 생성자를 호출할 때 사용
	+ 클래스 내의 다른 생성자를 호출
	+ __생성자__ 내에서만 사용 가능
	+ 반드시 생성자 코드의 제일 처음에 수행
	
### 객체(object)
+ 클래스의 모양대로 생성된 실체 (instance)
+ 프로그램 실행 중에 생성되는 실체
+ 메모리 공간을 갖는 구체적인 실체
+ 객체 내 데이터에 대한 보호, 외부 접근 제한
+ 객체 생성시 반드시 new 키워드 이용 `Circle donut = new Circle();`

+ 객체의 치환 
	+ 객체가 복사되는 것이 아니라, 레퍼런스가 복사된다.
	+ 원래 가리키던 객체를 아무도 가리키지 않게 되면, 가비지(garbage)라고 부름 
	
+ 객체 배열

```java
Circle [] c; // 이때 [5] 처럼 배열의 크기를 지정하면 오류 발생함
c = new Circle[5];

for (int i=0; i<c.length; i++)
	c[i] = new circle(i);

// CircleArray.java 참고
```

___

## 메소드
### 메소드 형식
+ 메소드 : 클래스의 멤버 함수로, 모든 메소드는 클래스 안에 있어야 함
	+ 구성 형식
		+ 접근 지정자
		+ 리턴 타입

+ 인자 전달 방식
	+ Pass-by-value (Call-by-value)
	+ 인자의 값이 메소드의 매개변수에 복사됨
		+ 기본 타입의 값 전달 혹은 객체나 배열의 레퍼런스 전달

### 메소드 오버로딩
+ 이름이 같은 메소드 작성
+ 근본적으로 동일한 작업을 함
+ 매개변수의 타입, 개수, 순서가 달라야 함

```java
class MethodOverloading{
	pulic int getSum(int i, int j){
		return i+j;
	}
	public int getSum(int t, int j, int k){
	 	return i+j+K;
	}
}
```

___

## 객체의 소멸과 가비지 컬렉션
+ 객체 소멸 : new에 의해 할당된 객체의 메모리를 자바 가상 기계의 가용 메모리로 되돌려 주는 행위
	> 임의로 객체 소멸 불가, 자바 가상 기계의 고유한 역할
+ 가비지 : 레퍼런스가 하나도 없는 객체
+ 가비지 컬렉션 : 자바 가상 기계의 가비지 컬렉터가 자동으로 가비지 수집 반환
	+ 가용 메모리로 반환
	+ 가비지 컬렉션 스레드에 의해 수행
	+ System 혹은 Runtime 객체의 gc() 메소드 호출 `System.gc();`
		+ 요청일 뿐 실행은 자바 가상 기계가 판단
		
___

## 접근 지정자(Access Specifier)
+ 패키지 : 서로 관련있는 클래스 파일들을 한 패키지에 저장하여 관리, 디렉터리 혹은 폴더와 같은 개념
+ 접근 지정자 : 클래스나 멤버들을 다른 클래스에서 접근해도 되는지의 여부를 선언하는 지시어
+ 클래스 접근 지정
	+ public : 다른 모든 클래스에게 허용
	+ default : 같은 패키지의 클래스에만 허용, 생략
+ 멤버 접근 지정
	+ private : 같은 클래스 안에서만 사용가능. 외부로부터 완벽 차단, 자식 클래스에서도 접근 불가
	+ default : 동일 패키지에 허용
	+ protected : 동일 패키지 및 다른 패키지에 있는 자식클래스에 허용
	+ public : 패키지 관계 없이 모든 클래스에 허용

___

## Static과 non-static 멤버
1. non-static 멤버
+ 공간적 특성 : 객체마다 독립적으로 별도로 존재
+ 시간적 특성 : 필드와 메소드는 객체 생성 후에야 사용 가능
+ 비공유 특성 : 다른 객체에 공유되지 않고 배타적, 객체 내 공간에 존재

2. static 멤버
+ 객체마다 생기는 것이 아님
+ 클래스 당 하나만 생성됨 -> 클래스 멤버 // 걍 가볍게 보기... 공유한다는 뜻 선언이 하나만 된다 x 
+ 객체를 생성하지 않고도 사용 가능 
+ static 멤버가 생성되는 시점은, 해당 클래스가 로딩되는 시점
+ 접근 방식 : 객체.staticField, 객체.staticMethod

### static의 활용
+ 전역변수와 전역 함수를 만들 때 활용
+ 공유 멤버를 만들 때 : static으로 선언된 필드나 메소드는 하나만 생성되어, 객체들 사이에서 공유됨

### static 메소드의 제약조건
+ non-static 멤버에 접근할 수 없다. 객체 없이도 존재하기 때문에 객체와 함께 생성되는 non-static 멤버 사용 불가, 역 성립
+ this 사용 불가. 객체 없이도 존재하기 때문

___

## final 
1. final class
+ 클래스 앞에 final이 붙으면, 이 클래스를 상속할 수 없음을 의미
2. final method
+ 오버라이딩 불가한 메소드
+ 자식 클래스가 부모 클래스의 특정 메소드를 오버라이딩 못하게 하고, 무조건 상속받아 사용하고자 할 때 사용
3. final field
+ 상수 선언
```java
class SharedClass{
	public static final double PI = 3.14; // 전역변수 
}

// SharedClass 내에서는
double area = PI;

// 다른 클래스에서는
double area = SharedClass.PI;
